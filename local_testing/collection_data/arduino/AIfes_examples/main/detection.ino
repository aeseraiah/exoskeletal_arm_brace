// This file covers the prediction of movement

float model_predictions(EMGData data[32], unsigned int number_data_points) {

  //AIfES requires random weights for training
  //Here the random seed is generated by the noise of an analog pin
  srand(analogRead(A5));
  uint32_t i;

  double biArray[number_data_points];
  double triArray[number_data_points];

  for (int i = 0; i < number_data_points; ++i) {
      // Store the first column values (biRMS) in biArray
      biArray[i] = data[i].biRMS;
      triArray[i] = data[i].triRMS;
  }

/////// TRAIN WITH REAL-TIME DATA /////////////////////////
  float input_data[number_data_points*2];

  // Populate input_data array with biArray and triArray values
  for (int i = 0; i < number_data_points; ++i) {
      input_data[i * 2] = biArray[i];
      input_data[i * 2 + 1] = triArray[i];
  }
///////////////////////////////////////////////////////////

  uint16_t input_shape[] = {number_data_points, 2};                                 
  aitensor_t input_tensor = AITENSOR_2D_F32(input_shape, input_data);   // Creation of the input AIfES tensor

  // Tensor for the output with 3 classes
  // Output values of the ANN are saved here
  float output_data[number_data_points*1];                                                    // Array for storage of the output data, for each object/class one output is created
  uint16_t output_shape[] = {number_data_points, 1};                                       // Definition of the shape of the tensor, here: {1 (i.e. 1 sample), 3 (i.e. the sample contains predictions for 3 classes/objects)}
  aitensor_t output_tensor = AITENSOR_2D_F32(output_shape, output_data);  // Creation of the output AIfES tensor

  aialgo_inference_model(&model, &input_tensor, &output_tensor);

  Serial.println(F(""));
  Serial.println(F("PREDICTIONS:"));
  Serial.println(F("input 1:\tinput 2:\tcalculated output:\tpredicted label:"));
  
  uint32_t input_counter = 0;
  float predicted_labels[number_data_points*1];

  // ----------------------------------------- Output of results --------------------------
  
  for (i = 0; i < number_data_points; i++) {
    Serial.print(input_data[input_counter]);
    //Serial.print(((float* ) input_tensor.data)[i]); //Alternative print for the tensor
    input_counter++;
    Serial.print(F("\t\t"));
    Serial.print(input_data[input_counter]);
    input_counter++;
    Serial.print(F("\t\t"));
    Serial.print(output_data[i]);
    if (output_data[i] > 0.5) {
      // ACTUATE SERVO:
      // myservo.write(180);
      predicted_labels[i] = 1;
    } 
    else {
      // myservo.write(0);
      predicted_labels[i] = 0;
    }
    Serial.print(F("\t\t\t"));
    Serial.println(predicted_labels[i]);
  }

  float arr = 1.0;
  return arr;

  // Reduce the output speed to be able to read the result of the detection comfortably
  //delay(1000);

}
